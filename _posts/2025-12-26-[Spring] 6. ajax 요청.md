---
title: "[Spring] 6. ajax 요청"
author: chunbae
date: 2026-01-03 01:00:00 +0900
categories: [Spring, Coding_apple]
tags: [spring, ajax, fetch, requestbody, requestparam, query-string]
render_with_liquid: falses
---

## AJAX

<br>

AJAX의 핵심은 페이지 새로고침 없이 데이터를 불러와 화면 일부분의 내용만 수정한다는 점이다.

<br>

> ### AJAX 장점

- **새로고침 없이도 데이터 불러오기**<br>웹사이트가 마치 설치형 앱처럼 부드럽게 작동한다.
<br>
- **서버 부하 감소**<br>매번 전체 HTML을 다시 만들어 보내야 했던 이전 방식과는 달리,<br>AJAX는 딱 필요한 **데이터(주로 JSON형식)**만 주고받는다.<br>서버 입장에서는 보내야 할 데이터 양이 줄어들게 된다.
<br>
- **대역폭 절약**<br>중복되는 헤더, 푸터, 메뉴 바 데이터를 제외하고 순수 데이터만 전송하므로<br>네트워크 자원을 효율적으로 사용한다.
<br>
- **비동기 처리**<br>데이터를 요청하고 응답을 기다리는 동안에도<br>사용자는 페이지의 다른 기능을 계속 사용할 수 있다.

<br><br>

> ### AJAX 단점

- **뒤로가기 문제**<br>페이지 새로고침(이동) 없이 내부 데이터만 바뀌기 때문에<br>브라우저 '뒤로가기'버튼을 눌렀을 때<br>사용자가 예상한 이전 상태로 돌아가지 않는 경우가 많다.<br>(History API 를 통해 보완 가능)
<br>
- **검색 엔진 최적화 어려움**<br>검색 엔진 로봇이 페이지를 방문했을 때,<br>AJAX로 불러오는 콘텐트는 초기 HTML에 포함되지 않아<br>인덱싱이 되지 않을 수 있음.<br>(최근에는 구글 봇 등이 js를 해석하지만, 여전히 SSR에 비해 불리함.)
<br>
- **보안 이슈**<br>클라이언트 측에서 로직이 수행되므로 소스코드가 노출되기 쉽고,<br>Cross-Site Scripting(XSS)같은 공격에 대비한 철저한 보안 설계가 필요함.
<br>
- **디버깅의 복잡성**<br>비동기 방식으로 동작하기 때문에<br>코드가 실행되는 순서가 직관적이지 않을 수 있어<br>에러를 찾기가 상대적으로 까다로움.

<br><br>

> ### AJAX 활용 예시

- **네이버/구글 검색창**: 검색어를 입력할 때 실시간으로 추천 검색어가 뜨는 기능
<br>
- **무한 스크롤**: 인스타, 유튜브에서 끊임없이 아래로 스크롤 할 수 있는 기능
<br>
- **실시간 차트**: 주식이나 코인 거래소에서 페이지 새로고침 없이 숫자가 계속 바뀌는 모습

<br><br>

## AJAX로 요청 날리기

웹페이지에서 서버에 요청을 날리는 방법으로는 크게 세 가지가 있다.<br><br>
1. 주소창에 URL 입력 (GET 요청 가능)
<br>
2. form 태그 사용 (GET 또는 POST 요청 가능)
<br>
3. AJAX 사용 (전부 사용 가능)

<br><br>

주소창 혹은 form 태그 사용 시 항상 자동 새로고침 되는데,<br>AJAX 사용 시 사이트 새로고침 없이도 서버로 요청을 날리 수 있다.

<br>

AJAX로 요청을 날리기 위해선 자바스크립트 `fetch('/url')`를 사용하면 된다.

<br>

```html
<script>
    fetch('/test1')
</script>
```

<br>

위 코드는 `'/test1'` URL로 GET 요청을 날린다.<br>Controller에서 `@GetMapping("/test1")`을 통해 캐치할 수 있다.

<br><br>

> ### 데이터 전송

fetch 함수의 두 번째 인자로는 요청에 함께 보낼 데이터를 넣는다.

<br>

```html
<script>
    fetch('/test1', {
        method: 'POST',
        headers: {
            "Content-Type": "application/json",
        },
        body: JSON.stringify({ title: 'kim', price: 123 })
    })
<script>
```

<br>

* `method` 속성을 통해 어떤 method로 요청할 지 설정할 수 있다.
<br>
* `body` 속성을 통해 어떤 데이터를 서버로 보낼지 설정할 수 있다.<br>전송할 데이터가 많으면 자바스크립트 array나 object 안에 담아서 전송해도 된다.<br>이 때, array나 object를 JSON.stringify() 안에 넣어서 전달해야 하고,<br>타입을 *application/json*으로 기입해야 한다.
<br>
* `headers` 속성을 통해 헤더 설정도 가능하다.

<br><br>

> ### 서버에서 데이터 수신

```java
@PostMapping("/test1")
public String test(@RequestBody Map<String, Object> body) {
    
    System.out.println(body.get("name"));
    return "redirect:/list";

}
```

<br>

AJAX로 *application/json* 타입의 데이터를 보냈다면<br>파라미터에 `@RequestBody`를 붙여 받아올 수 있다.
<br><br>
어노테이션 뒤에는 변환할 자료형을 입력하면 되는데<br>자바스크립트의 object 형태로 보냈다면 Map으로 간편하게 변환하여 사용하면 된다.

<br>

```java
@PostMapping("/test1")
public String test(@RequestBody Item item) {
    
    System.out.println(body);
    return "redirect:/list";

}
```

<br>

Map 말고 특정 객체로 바로 변환할 수도 있다.

<br><br>

> ### 특정 버튼을 누를 때 fetch 함수 실행

일반적으로 <script> fetch("/url1") </script> 같이 작성하면<br>웹페이지가 열린 뒤 최초 1회만 실행된다.

<br>

```html
<button class="btn">버튼</button>

<script>
    document.querySelectorAll('.btn')[0].addEventListener('click', function() {
        fetch('/test')
    })
</script>
```

<br>

그러나 위와 같이 작성하면 `버튼`을 클릭할 때 마다<br>**'/test'**로 GET요청을 보내게 된다.

<br>

```html
<button onclick="fetch('/test1')">버튼</button>
```

<br>

위와 같이 작성하는 것도 가능하다.

<br><br>

## Query String

> ### Query String으로 데이터 전송

```html
<script>
    fetch('/test?name=kim&age=10')
</script>
```

<br>

fetch 두 번째 인자를 통해 데이터를 전달하는 대신,<br>url에 데이터를 포함하여 전달해 줄 수 있다.

<br><br>

쿼리 스트링은 정해진 규칙에 따라 작성된다.
<br>
- **물음표(?)로 시작**: URL경로가 끝나고 query string이 시작됨을 알림
<br>
- **구분자(&)**: 여러 개의 데이터를 보낼 때 각 쌍을 구분함
<br>
- **Key와 Value**: `키=값` 형태로 전달함
<br>
- **인코딩**: 공백이나 특수 문자는 `%20`처럼 특수한 형태로 변환(URL encoding)되어 전달됨

<br><br>

query string은 데이터가 URL에 그대로 노출되다 보니 **보안에 취약**하다.
<br>
또한 URL의 길이 제한이 있어 긴 데이터는 전송할 수 없다.
<br><br>
반면에query string이 포함된 URL 브라우저에 기록이 남고,<br>즐겨찾기 저장이 가능하다는 장점이 있다.<br>이는 검색 필터나 페이지 번호를 공유할 때 매우 유용하다.

<br><br>

> ### 서버에서 데이터 수신

```java
@GetMapping("/test")
public String test(@RequestParam Long id) {
    ...
}
```

<br>

서버에서 query string으로 보낸 데이터를 받고 싶으면<br>`@RequestParam` 어노테이션을 사용하면 된다.

<br><br>

## AJAX를 이용한 게시글 삭제 기능 구현

```html
(list.html)

<div th:each="item: ${items}">
    <h4>
        <a th:text="${item.getTitle()}">상품명</a>
    </h4>
    <p th:text="${item.getPrice()}">가격</p>
    <form action="/delete method="POST">
        <input type="hidden" name="id" th:value="${item.id}">
        <button type="submit">삭제</button>
    </form>
</div>
```
```java
(ItemController.java)

@PostMapping("/delete")
public String delete(Long id) {

    itemService.delete(id);
    return "redirect:/list";

}
```

<br>

위 코드는 이전에 form 태그를 이용해 구현한 코드이다.<br><br>form 태그에서는 **GET** 또는 **POST** 요청밖에 날릴 수 없기에<br>`/delete`로 **POST** 요청을 날리는 것을 볼 수 있다.
<br><br>
그러나 delete 요청의 경우 POST보다는 **DELETE** 메소드가 더 적절하다.<br>AJAX는 method 제한이 없으므로, **DELETE** 요청을 날리는 것이 가능하다.
<br><br>
아래는 AJAX를 사용해 **DELETE** 요청을 보내는 코드이다.

<br>

```html
(list.html)

<div th:each="item: ${items}">
    <h4>
        <a th:text="${item.getTitle()}">상품명</a>
    </h4>
    <p th:text="${item.getPrice()}">가격</p>
    <span onclick="fetch('/item?id=[[${item.id}]]', { method: 'DELETE' })">삭제</span>
</div>
```

```java
(ItemController.java)

@DeleteMapping("/item")
public ResponseEntity<String> delete(@RequestParam Long id) {

    itemService.delete(id);
    return ResponseEntity.status(200).body("삭제 완료");

}
```

<br>

Thymeleaf를 통해 서버에서 받은 데이터를 사용하고 싶다면<br>`[[${변수명}]]`과 같이 코드를 작성하면 된다.

<br>

AJAX로 데이터를 주고받을 시 서버측에서 HTML을 전송하거나 redirect하는 것이 불가능하기 때문에<br>ResponseEntity 정도로 메시지만 보내주면 된다.

<br>

위 코드는 URL 파라미터를 통해서 다음과 같이 쉽게 구현할 수도 있다.

<br>

```html
(list.html)

<span onclick="fetch('/item/[[$item.id}]]')>삭제</span>
```

```java
(ItemController.java)

@DeleteMapping("/item/{id}")
public ResponseEntity<String> delete(@RequestParam Long id) {

    itemService.delete(id);
    return ResponseEntity.status(200).body("삭제 완료");

}
```

<br><br>

### AJAX 요청 완료 시에 코드 실행

위 코드는 약간의 문제가 있다.<br>물품 삭제 버튼을 누른 뒤에도 페이지를 새로고침하기 전까지 화면에 남아있다는 것이다.
<br><br>
해결방법은 두 가지인데,<br>
1. 강제 새로고침
<br>
2. 방금 삭제한 박스 타입 숨김처리

<br><br>

```html
(list.html)

<span onclick="fetch('/item?=[[$item.id}]]', { method: 'DELETE' })
    .then(r => r.text())
    .then(result => { 서버응답이 오면 실행할 코드 })
">삭제</span>
```

<br>

AJAX 요청 후에 서버가 보낸 데이터를 출력해보고 싶으면<br>`then()`을 두 번 붙여주면 된다.
<br><br>
`result`변수에는 서버가 보낸 자료가 들어있는데, 서버가 보내주는게 문자열이면 `r.text()`를,<br>서버가 보내주는게 List나 Map 자료형이면 `r.json()`을 사용하면 된다.
<br><br>
`then()` 안에 `window.location.reload()` 코드를 통해 페이지 새로고침을,<br>`e.parentElement.parentElement.style.display = 'none'` 코드를 통해 지금 누른 버튼의 부모의 부모 태그를 안보이게 처리할 수도 있다.

<br><br>

## 출처
- [코딩애플 쉽게 배우는 Spring Boot & JPA](https://codingapple.com/course-status/)