---
title: "[Spring] 5. 예외 처리, html 태그 재사용"
author: chunbae
date: 2026-01-03 00:00:00 +0900
categories: [Spring, Coding_apple]
tags: [spring, thymeleaf, rest-api, error.html, try-catch, exception, exception-handler, controller-advice, th-replace]
render_with_liquid: falses
---

## 예외처리하기

서버 개발 시에는 항상 예외 상황을 가정하고 코드를 작성해야 한다.<br><br>간단한 예외 상황은 if문이나 try-catch 블록으로 걸러낼 수 있지만,<br>그것으로 부족한 경우가 있다.
<br><br>
아래 코드를 보자.
<br><br>
다음과 같이 코드를 작성 시 사용자가 `/detail/abc` 주소로 접근 한다면<br>abc를 Long 타입으로 변환하는 과정에서 에러가 발생한다.

<br>

```java
@GetMapping("/detail/{id}")
public String getDetail(PathVariable Long id) {
    ...
}
```

<br><br>

Thymeleaf를 설치해서 사용하는 경우, 그냥 `error.html` 파일만 만들어두면<br>서버에서 에러 발생 시 자동으로 해당 페이지로 이동한다.

<br>

```html
(error.html)

<div>에러페이지입니다.</div>
<p th:text=${status}"></p>
<p th:text=${error}"></p>
<p th:text=${path}"></p>
<p th:text=${message}"></p>
<p th:text=${exception}"></p>
```

<br>

![Desktop View](/assets/img/[Spring]4.게시글추가,삭제,수정기능구현/img01.png){: width="954" height="368" }

<br><br>

또한 기본적으로 **status, error, path**등 에러와 관련된 여러 변수들이 함께 전송되기에<br>해당 내용을 기반으로 에러 페이지를 꾸밀 수 있다.

<br><br>

## REST API 의 예외 처리

Thymeleaf 사용 시 `error.html` 페이지로 이동하는 게 예외처리 전부라고 했다.<br><br>그러나 서버에서 데이터만 보내주는 **REST API**를 구축하는 상황에서는<br> `error.html` 페이지를 보내봤자 아무 의미가 없다.
<br><br>
따라서 이 때는 다른 방법으로 예외를 처리해야 한다.

> ### try-catch 문으로 처리

```java
@GetMapping("/detail/{id}")
@ResponseBody
String detail() {
    try {
        throw new Exception("~~에러 발생");
    } catch(Exception e) {
        System.out.println(e.getMessage());
        return "에러가 발생했습니다.";
    }
}
```

<br>

> 참고1<br>`throw new Exception("")` 코드를 통해 강제로 에러를 발생시킬 수 있다.

<br>

> 참고2<br>실제 서비스 배포 후에는 `System.out.println()` 보다는 **로깅 라이브러리**를 사용하는 것이 낫다.

<br><br>

> ### throws Exception

```java
@GetMapping("/detail/{id}")
@ResponseBody
String detail() throws Exception {
    throw new Exception("~~에러 발생");
}
```

<br>메소드 내에서 에러가 발생하였는데, try-catch문이 없다면 `throws`를 통해 밖으로 던질 수 있다.

<br><br>

> ### ResponseEntity

```java
@GetMapping("/detail/{id}")
ResponseEntity<String> detail() {
    try {
        throw new Exception("~~에러 발생");
    } catch(Exception e) {
        return ResponseEntity.status(에러코드).body("에러 사유");
    }
}
```

<br>

> 참고<br>ResponseEntity 사용 시 굳이 @ResponseBody 어노테이션을 붙이지 않아도 된다.<br>한글 보낼 때 안깨지는 것도 편리함.

<br><br>

에러 발생 시 문자만 달랑 보내기보다는 더 정확하게 **에러 코드**도 기입해서 보내줄 수 있다.<br><br>ResponseEntity 클래스를 사용하면 에러 코드는 뭔지,<br>에러이유는 무엇인지 보다 자세하게 알려줄 수 있다.<br>프론트 개발자들은 API에 요청날릴 때 어떤 에러가 발생하는지<br>빠르게 원인을 파악할 수 있게 된다.
<br><br>
.status() 안에는 에러코드를 숫자로 입력하면 된다.<br>아주 간단하게 설명하자면<br><br>- `400`: 유저 잘못으로 인한 에러<br>- `500`: 서버 잘못으로 인한 에러<br>- `200`: 에러 없이 정상 작동<br><br>를 넣어주는 것이 관습적이다.<br>에러났을 뿐 아니라 평소에 REST API를 만들 때에도 200을 기재하여 보내주는 것이 좋다.

<br>

참고: HTTP Status code
![Desktop View](/assets/img/[Spring]4.게시글추가,삭제,수정기능구현/img02.png){: width="1027" height="1046" }_출처: 코딩애플_

<br><br>

> ### @ExceptionHandler

try-catch문으로는 위에 `/detail/abc`와 같이
메소드 외부에서 발생한 오류는 처리할 수 없다.
<br><br>Spring boot에서는 `@ExceptionHandler`라는 간편한 예외처리 기능을 제공한다.

<br>

```java
(A.java)

@ExceptionHandler(Exception.class)
public ResponseEntity<String> exceptionHandler() {
    return ResponseEntity.status(400).body("A클래스에서 에러 발생 시 실행됨.");
}
```

<br>

컨트롤러 클래스의 다른 API와 나란하게 `@ExceptionHandler` 붙은 메소드를 작성하면 된다.<br><br>`@ExceptionHandler` 사용 시 해당 클래스(A)에서 에러가 발생하면<br>`@ExceptionHandler` 어노테이션이 붙은 메소드가 호출된다.
<br><br>
그러나 만약 컨트롤러 클래스가 100만개 있다면,<br>위 코드도 100만 번 작성해야 한다는 단점이 있다.<br><br>이는 `@ControllerAdvice`를 사용하여 보완할 수 있다.

<br><br>

> ### @ControllerAdvice

```java
(MyExceptionHandler.java)

@ControllerAdvice
public class MyExceptionHandler {

    @ExceptionHandler(Exception.class)
    public ResponseEntity<String> handler() {
        return ResponseEntity.status(400).body("모든 컨트롤러에서 에러 시 실행됨.");
    }
}
```

<br>

아무 곳에나 java 파일을 만들고,<br>class 위에 `@ControllerAdvice`를 붙여준다.<br><br>그 다음엔 아까와 같이 `@ExceptionHandler`를 넣어주면 된다.<br><br>위와 같이 코드를 작성하게 되면 **모든 컨트롤러에서 에러가 나는 경우**위 코드가 실행된다.
<br><br>
참고로, 개별 컨트롤러에도 `@ExceptionHandler`를 만들어놨고, 여기에도 만들어놨으면<br>개별 컨트롤러의 `@ExceptionHandler`가 우선권을 가지게 된다.

<br><br>

> ### 특정 에러에만 실행

`@ExceptionHandler`에 넣는 파라미터에 따라 특정 에러에서만 실행되게 할 수 도 있다.

<br>

```java
@ExceptionHandler(MethodArgumentTypeMismatchException.class)
public ResponseEntity<String> handler() {
    return ResponseEntity.status(400).body("특정 에러에만 작동됨.");
}
```

<br>

위 코드는 *MethodArgumentTypeMismatchException*이 발생했을 때만 실행된다.

<br><br>

## 결론

* Thymeleaf 사용시엔 `error.html` 작성으로 에러 처리가 가능하다.

<br>

* REST API 구축 시 `@ControllerAdvice`를 작성하는 것이 편리하다.

<br><br>

---

## Thymeleaf 사용하여 HTML 태그 재사용하기

여러 파일에 동일하게 사용되는 HTML 태그(ex. 네비게이션 바)는 <br>별도 파일로 뺀 다음에 이거를 가져다 쓰는 식으로 사용할 수 있다.
<br><br>

### 1. 별도 HTML 파일 생성

재사용하고자 하는 HTML 태그를 별도 파일로 뺀다

<br>

```html
(nav.html)

<div class="nav" th:fragment="navbar">
    <a class="logo">SpringMall</a>
    <a>List</a>
    <a>Write</a>
</div>
```

<br>

위에서 `th:fragment`는 자바에의 메소드명과 동일한 역할을 수행한다고 이해하면 쉽다.

<br>

이렇게 작성한 HTML 태그를 다른 HTML 파일에서 사용하려면 다음 한 줄만 작성해 주면 된다.

```html
<div th:replace="~{ nav.html :: navbar }"></div>
```

<br>

> 참고<br>`th:fragment`정의는 한 파일에 여러 번 사용해도 된다.

<br><br>

## 출처
- [코딩애플 쉽게 배우는 Spring Boot & JPA](https://codingapple.com/course-status/)