---
title: "다익스트라 알고리즘"
author: chunbae
date: 2024-05-02 00:00:00 +0900
categories: [Java, Algorithm]
tags: [java, algorithm, dijkstra]
render_with_liquid: falses
---

## 다익스트라(Dijkstra) 알고리즘이란?

| 최단거리 알고리즘             |
|:----------------------------:|
| 다익스트라(Dijkstra)          |
| 벨만-포드(Bellman-Frod)       |
| 플로이드-와샬(Floyd-Wrasahll)  |

### 다익스트라 알고리즘
- 가중치 그래프의 최단 경로를 구하는 알고리즘
- 출발지가 정해져 있음
  출발지에서 다른 모든 노드까지의 최단거리를 구하는 알고리즘
- 음수 가중치가 없어야함
- 인접 행렬로 표현된 그래프의 경우 시간 복잡도 `O(n^2)`
- `우선순위 큐`를 사용할 시 시간복잡도 `O((V+E)logV)` -> 개선된 다익스트라 알고리즘

### 다익스트라 알고리즘의 매커니즘
- `그리디 알고리즘`과 `다이나믹 프로그래밍` 기법을 사용한 알고리즘이다.
- 아래 두 단계를 반복하여 임의의 노드에서 각 모든 노드까지의 최단거리를 구한다. 임의의 노드에서 다른 노드로 가는 값을 **비용**이라고 한다.
1. **방문하지 않은 노드 중**에서 `출발지 -> 노드`까지의 **비용이 가장 적은 노드를 선택** (그리디 알고리즘)
2. (1)에서 선택된 노드로부터 갈 수 있는 **노드들의 비용을 갱신** (다이나믹 프로그래밍)

### 예시 ([출처](https://sskl660.tistory.com/59))
다음 그림에서 **출발지**가 **A노드**, **도착지**가 **F노드**라고 하자.

### 0. 그래프가 주어짐

![Desktop View](/assets/img/다익스트라알고리즘/img01.png){: width="567" height="382" }
_출처 : https://sskl660.tistory.com/59_

**방문여부**를 나타내는 배열 `visited`, 출발지 A부터 n노드까지 가는데 드는 **최소비용**을 `dist[n]`이라고 정의하자.

```txt
visited = [0, 0, 0, 0, 0, 0]
dist = [?, ?, ?, ?, ?, ?]
```

### 1. 시작점 초기화
**0단계**에서 방문하지 않은 노드 중 `출발지 -> 노드`까지의 비용이 가장 적은 노드는 어디일까? A노드에서 다른 노드로 가는 비용이 0인 간선이 존재하지 않는다면, 당연히 **A노드 자신**일 것이다.
<br>
(만약 그러한 값이 존재한다고 하더라도 첫 번째 단계에서는 '**출발지에서 출발지로 가는 비용이 가장 적다**'라고 정의하고 시작한다.)
<br>
<br>
즉, 첫 번째 단계에서는 출발지인 A노드 자신을 초기 선택 노드로 초기화한다.

```txt
visited = [1, 0, 0, 0, 0, 0]
dist = [0, 2, 5, 3, ?, ?]
```

### 2. 알고리즘 적용
출발지 초기화가 끝났으니, 앞서 언급한 두 가지 논리를 그냥 반복해서 적용하면 끝이다. 

> I. **방문하지 않은 노드 중**에서 `출발지 -> 노드`까지의 **비용이 가장 적은 노드를 선택**<br> II. (I)에서 선택된 노드로부터 갈 수 있는 **노드들의 비용을 갱신**

![Desktop View](/assets/img/다익스트라알고리즘/img03.png){: width="506" height="406" }
_출처 : https://sskl660.tistory.com/59_

위 상태에서 **방문하지 않는 노드 중** `출발지 -> 노드`까지의 **비용이 가장 적은 노드**는 어디인가?
<br>
A노드는 방문하였기 때문에, B노드가 될 것이다. 따라서 B노드를 방문하고, B노드와 인접한 노드들의 최소 비용을 갱신해주면 된다.

![Desktop View](/assets/img/다익스트라알고리즘/img04.png){: width="532" height="424" }
_출처 : https://sskl660.tistory.com/59_

```txt
visited = [1, 1, 0, 0, 0, 0]
dist = [0, 2, 5, 3, ?, 12]
```

B를 거쳐 C로 가는 경로의 비용은 9이다. 하지만 이미 `dist[C]`값이 5이므로 갱신할 필요가 없다.
<br>
아직 `dist[F]` 값이 정해지지 않았으므로, B를 거쳐 F에 도착하는 경로의 비용인 12로 설정해 두었다.
<br>
<br>
다음 단계도 마찬가지다. 이제는 A노드와 B노드를 방문하였기에, **방문하지 않는 노드 중** `출발지->노드`까지의 **비용이 가장 적은 노드인** D노드를 선택하고 방문한 뒤, 같은 과정을 진행해 주면 된다.

![Desktop View](/assets/img/다익스트라알고리즘/img05.png){: width="540" height="434" }
_출처 : https://sskl660.tistory.com/59_

```txt
visited = [1, 1, 0, 1, 0, 0]
dist = [0, 2, 4, 3, 10, 12]
```

D를 거쳐 C로 가는 경로의 비용은 4이다. 현재 `dist[C]`의 값인 5보다 적으므로 `dist[C]`값을 4로 갱신한다.
<br>
아직 dist[E]값이 정해지지 않았으므로, D를 거쳐 E에 도착하는 경로의 비용인 10으로 설정해 두었다.

![Desktop View](/assets/img/다익스트라알고리즘/img06.png){: width="541" height="455" }
_출처 : https://sskl660.tistory.com/59_

```txt
visited = [1, 1, 1, 1, 0, 0]
dist = [0, 2, 4, 3, 6, 9]
```

C를 거쳐 E로 가는 겨올와 F로 가는 경로는 각각 `dist[E]`, `dist[F]`값보다 모두 작다. 따라서 dist의 각 값을 갱신할 수 있다.

![Desktop View](/assets/img/다익스트라알고리즘/img07.png){: width="557" height="425" }
_출처 : https://sskl660.tistory.com/59_

```txt
visited = [1, 1, 1, 1, 1, 0]
dist = [0, 2, 4, 3, 6, 8]
```

E노드를 거쳐 F노드로 가는 비용은 `dist[F]`값보다 작다. 따라서 그 값을 갱신할 수 있다.

![Desktop View](/assets/img/다익스트라알고리즘/img08.png){: width="525" height="402" }
_출처 : https://sskl660.tistory.com/59_

```txt
visited = [1, 1, 1, 1, 1, 1]
dist = [0, 2, 4, 3, 6, 8]
```
<br>

## 출처

- [[Java]다익스트라 알고리즘(Dijkstra Algorithm)](https://sskl660.tistory.com/59)
- [[Algorithm/Java] 다익스트라(dijkstra) 알고리즘 (최단거리, 가중치 그래프)](https://innovation123.tistory.com/130)
- [[알고리즘/Java]다익스트라(Dijkstra) 알고리즘](https://velog.io/@suk13574/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98Java%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BCDijkstra-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98)
- [BOJ 1753-최단경로](https://www.acmicpc.net/problem/1753)