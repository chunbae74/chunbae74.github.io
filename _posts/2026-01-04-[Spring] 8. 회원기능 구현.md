---
title: "[Spring] 8. 회원기능 구현"
author: chunbae
date: 2026-01-04 01:00:00 +0900
categories: [Spring, Coding_apple]
tags: [spring, ]
render_with_liquid: falses
---

## 회원가입 기능 구현

<br>

회원가입 기능 구현은 다음과 같은 과정을 따르면 된다.
<br>

1. `/register` 페이지 접속 시 회원가입 페이지로 이동
<br>2. 전송 버튼 누르면 서버로 보내고, 서버는 이를 DB에 저장

<br>

### 1. /register 페이지 접속 시 회원가입 페이지로 이동

```java
(MemberController.java)

@GetMapping("/register")
public String register() {

  return "register.html";

}
```

<br>
회원기능은 기존의 글작성기능이랑은 좀 다른 주제이기 때문에<br>새로 MemberController를 만들어 거기에 코드를 작성하겠다.<br>같은 클래스 안에는 같은 주제의 함수들을 담는 것이 좋다.

<br>

```html
(register.html)

<form action="/member" method="POST">
  <input name="displayName" placeholder="이름">
  <input name="username" placeholder="아이디">
  <input name="password" type="password">
  <button type="submit">전송</button>
</form>
```

<br><br>

### 2. 전송 버튼 누르면 서버로 보내고, 서버는 이를 DB에 저장

> **DB 테이블 생성**

먼저, 회원정보를 관리할 DB 테이블을 새로 만들어야 한다.<br>테이블 명은 Member, 필드값은 *id, displayName, username, password*로 하자.<br>password는 BCryptPasswordEncoder를 활용해 해싱하여 저장할 것이다.

<br>

BCryptPasswordEncoder 사용법은 다음과 같다.

```java
BCryptPasswordEncoder encoder = new BCryptPasswordEncoder();
String encodedStr = encoder.encode("qwer1234");
```

<br>

```java
(Member.java)

@Entity
@Getter
@Setter
public class Member {
  
  @Id @GeneratedValue(strategy=GenerationType.IDENTITY)
  public Long id;

  private String displayName;
  @Column(unique = true)
  private String username;
  private String password;

}
```

<br>

id인 username은 항상 유니크해야 하기 때문에 unique 제약을 주었다.

<br><br>

> **테이블 데이터 입출력**

JPA로 입출력하려면 3-step이 필요하다.
<br>1. interface 생성
<br>2. Controller(Service)에 객체 등록
<br>3. 사용

<br>

```java
(MemberRepository.java)

public interface MemberRepository extends JpaRepository(Member, Long) {

}
```

```java
(MemberController.java)

@PostMapping("/member")
public String signup(String displayName, String userName, String password) {
 
  memberService.signup(displayName, userName, password);
  return "redirect:/list";

}
```

```java
(MemberService.java)

@Service
@RequiredArgsCOnstructor
public class MemberService {
  
  private final MemberRepository memberRepository;

  public void signup(String displayName, String username, String password) {
    
    Member member = new Member();
    member.setDisplayName(displayName);
    member.setUsername(username);
    String encodedPassword = new BCryptPasswordEncoder().encode(password);
    member.setPassword(encodedPassword);

    memberRepository.save(member);

  }
}
```

<br><br>

### Bean 으로 만들어 쓰기

위에서 작성한 코드를 보면<br>API를 실행할 때 마다 매번 `new BCryptPasswordEncoder()`로 객체를 새로 생성하고 있다.<br>이를 좀 더 효율적으로 작성하고 싶다면 spring에게 객체를 하나 뽑아달라고 한 다음<br>**Dependency Injection** 식으로 가져다 쓰면 된다.

<br>

Dependency Injection 을 구현하고 싶으면<br>
클래스를 하나 만들어서 `@Service`나 `@Component`같은 어노테이션을<br>붙여 등록한 뒤에 사용하면 된다고 했다.

<br>

그러나 BCryptPasswordEncoder 클래스는 이미 다른사람이 만들어놓은 클래스이다.<br>보통은 라이브러리에 작성되어 있는 코드를 우리가 직접 수정하지는 않는다.<br>이미 누가 만들어놓은 클래스를 Dependency Injection 식으로 사용하고 싶다면 다음과 같이 하면 된다.

<br>

```java
(SecurityConfig.java) 

@Configuration
@EnableWebSecurity
public class SecurityConfig {

  @Bean
  PasswordEncoder passwordEncoder() {
    return new BCryptPasswordEncoder();
  }

  ...

}
```

<br>

객체를 새로 생성하는 메소드를 하나 만든 뒤에<br>메소드가 속한 클래스에 `@Configuration`을, 메소드에 `@Bean`<br>어노테이션을 붙인다.

<br>

Bean을 사용하려면 *memberRepository*와 같이<br>평소에 하던대로 등록해서 쓰면 된다.

<br>

```java
(MemberService.java)

@Service
@RequiredArgsConstructor
public class MemberService {

  private final MemberRepository memberRepository;
  private final PasswordEncoder passwordEncoder;

  ...

}
```

<br><br>

## 로그인 기능 구현

Spring Security 라이브러리를 사용하는 경우, `@EnableSecurity` 어노테이션이<br>붙은 클래스를 통해 몇 가지 세팅만 해 주면 된다.

<br>

1. 로그인용 html 페이지를 만들고
<br>2. spring security 설정에 폼으로 로그인하겠다고 설정 해놓고
<br>3. DB에 있던 유저정보를 꺼내는 코드 작성

<br>

이렇게 작성하면 Session 방식의 로그인 기능이 작동한다.

<br>

### 1. 로그인용 html 페이지 만들기

```java
(MemberController.java)

@GetMapping("/login")
public String login() {
  return "login.html";
}
```

```html
<form action="/login" method="POST">
  <input name="displayName">
  <input name="username">
  <input name="password" type="password">
  <button type="submit">로그인</button>
</form>
```

<br>

### 2. spring security 설정에 폼으로 로그인하겠다고 설정

```java
(SecurityConfig.java)

@Configuration
@EnableWebSecurity
public class SecurityConfig {

  http.formLogin(formLogin -> 
    formLogin.loginPage("/login") // 로그인 페이지 URL
    .defaultSuccessUrl("/my-page") // 로그인이 성공했을 때 이동할 URL
    .failureUrl("/fail") // 실패 시 이동할 URL. (기본값: /login?error)
  );

}
```

<br>

앞으로 폼으로 로그인하겠다는 뜻이다.<br>성공이나 실패시 이동할 페이지 url도 설정 가능하다.<br>실패 시 이동할 페이지를 따로 지정해 주지 않을 시, **"/login?error"** 페이지로 이동한다.

<br>

query string으로 에러가 있었다는 것을 전달해 줌을 알 수 있는데<br>이를 이용해 로그인 실패 시 안내메시지 출력도 가능하다.

```html
(login.html)

<div th:if="${param.error}">
  <h4>아이디나 비번이 올바르지 않습니다</h4>
</div>
```

<br><br>

### 3. DB에 있던 유저 정보를 꺼내는 코드 작성

```java
(MyUserDetailService.java)

@Service
public class MyUserDetailService implements UserDetailService {

  @Override
  public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
    // DB에서 username을 가진 유저를 찾아온 뒤
    // return new User(유저아이디, 비번, 권한);
  }

}
```

<br>

필자는 `MyUserDetailService.java` 파일을 생성한 뒤<br>여기에 DB에 있던 유저 정보를 꺼내는 코드를 작성할 것이다.

<br><br>

### spring security 동작 흐름

로그인 과정이 실제로는 어떻게 이루어지는지 확인해 보자.

![Desktop View](/assets/img/[Spring]8.회원기능구현/img01.png){: width="1214" height="885" }_사진 출처 : 코딩애플_

<br>

유저가 폼으로 **username, password**라는 이름의 데이터들을 제출하면<br>사진에 있는 클래스들을 타고 이동하여<br>`3.UserDetailService`라는 클래스에 도착한다.

<br>

여기서 유저 정보를 DB에서 꺼내주기만 하면<br>DaoAuthenticationProvider가 알아서 유저가 제출한 비밀번호와 DB에서 꺼낸 비밀번호와 비교해본다.<br>만약 PasswordEncoder라는 Bean이 있다면, 해싱도 자동으로 해 준다.

<br>

이상이 있다면 에러를 발생시키고<br>별 이상 없다면 입장권용 쿠키를 하나 생성해 유저에게 보내준다.<br>누가 어떤 이름으로 언제 로그인하였는지와 같은 session 데이터도 생성해서 저장해준다.<br>또한 유저가 제출한 입장권 검사도 자동으로 수행해준다.

<br><br>

### loadUserByUsername 작성하기

유저 정보를 DB에서 꺼내주기만 한다면 값 비교부터 입장권 발권까지<br>스프링이 알아서 해 준다고 했다.
<br>그러면 유저 정보를 꺼내는 메소드인 `loadUserByUsername`를 완성해 보자.

```java
(MyUserDetailService.java)

@Service
public class MyUserDetailService implements UserDetailService {

  @Override
  public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
    // DB에서 username을 가진 유저를 찾아온 뒤
    // return new User(유저아이디, 비번, 권한);
  }
  
}
```

<br>

`loadByUsername` 함수에 파라미터를 추가하면<br>**유저가 로그인시 제출한 username**을 받아올 수 있다.

<br>

우리는 DB에서 username과 일치하는 회원을 찾아와<br>User객체에 담은 뒤에 return 해주기만 하면 된다.

<br><br>

> **테이블에서 특정 컬럼에 있는 값을 찾아오기**

우리가 배운 특정 행을 뽑아오는 메소드는 `.findById()`밖에 없다.<br>그러나 지금은 id가 아닌, username 컬럼을 바탕으로 찾아와야 한다.

<br>

`.findByUsername()` 같은 메소드는 없을까?<br>기존에는 없지만, **Derived Query Methods**를 통해 직접 만들 수 있다.

<br>

### Derived Query Methods

<br>- and, or 조건주기
<br>- 특정문자 포함되었는지 검색하기
<br>- 특정 숫자 이상/이하인거 검색하기
<br>- 정렬하기
<br>이런 여러 가지 작업을 하는 DB 입출력 문법을 생성할 수 있다.

<br><br>

메소드를 만들기 위해선 `MemberRepository.java`에 함수를 선언하기만 하면 된다.

<br>

```java
(MemberRepository.java)

public interface MemberRepository extends JpaRepository<Member, Long> {
  
  Optional<Member> findByUsername(String username);

}
```

<br>

해당 username을 가진 행이 없을 수도 있으니<br>반환타입은 Optional<Member>로 설정하였다.

<br>

이렇게 선언한 함수를 자유롭게 선언하면 된다.

<br>

```java
(MyUserDetailService.java)

@Service
@RequiredArgsConstructor
public class MyUserDetailService implements UserDetailService {

  private final MemberRepository memberRepository;

  @Override
  public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
    // DB에서 username을 가진 유저를 찾아온 뒤
    Optional<Member> optional = memberRepository.findByUsername(username);
    if (optional.isEmpty()) {
      throw new UsernameNotFoundException("해당 이름의 유저가 존재하지 않습니다.");
    }

    Member member = optional.get();
    User user = new User(member.getUsername(), member.getPassword(), 권한목록);
    // return new User(유저아이디, 비번, 권한);
    return user;

  }
  
}
```

<br>

> **권한 넣기**

<br>권한 또한 User 객체에 넣어주어야 한다.<br>이 유저의 권한들을 `SimpleGrantedAuthority` 타입으로 List에 넣으면 된다.

<br>

권한은 특별한 코드적인 기능은 없고 이 유저가<br>어떤 유저인지 메모해 놓은 것이라 생각하면 된다.<br>권한 작성 시 좋은 점이 뭐냐면 나중에 Controller 같은 곳에서 현재 유저의 로그인 정보를 출력해 볼 수 있는데<br>그 때 권한을 메모해 둔 것도 출력이 가능하다.<br>그래서 권한에 따라 특정 페이지나 API를 사용하지 못하게 할 수도 있다.

<br>

```java
@Override
public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
  
  (생략)
  List<GrantedAuthority> authorityList = new ArrayList<>();
  authorityList.add(new SimpleGrantedAuthority("일반유저"));
  User user = new User(member.getUsername(), member.getPassword(), authorityList);
  return user;

}
```

<br>

이것으로 로그인 기능 구현은 끝났다.<br>실제로 로그인을 시도해보면 잘 작동함을 확인해 볼 수 있다.

<br><br>

## 마이페이지 구현

`/my-page`에 접속하면 나의 정보를 출력하는 기능을 만들어보자.

<br>

```java
(MemberService.java)

@GetMapping("/my-page")
public String myPage() {
  return "mypage.html";
}
```

<br>

Thymeleaf의 `sec:authentication`이란 문법을 사용하면<br>현재 로그인 중인 유저정보를 쉽게 출력해 볼 수 있다.<br>일반적으로 서버에서 직접 정보를 보내지 않아도 돼 편리한데,<br>REST API의 경우엔 해당되지 않는다.

<br>

```html
<span sec:authentication="principal"></span>
<span sec:authentication="principal.username"></span>
<span sec:authentication="principal.authorities"></span>
```

<br>

또한 `sec:authorized` 문법을 통해<br>특정 조건 만족 시에만 문구가 보이도록 구현할 수도 있다.

<br>

```html
<span sec:authorized="hasAuthority('일반유저')">
  <h4>일반유저 권한만 볼 수 있는 문구입니다.</h4>
</span>

<span sec:authorized="isAuthenticated()">
  <h4>로그인 한 사람만 볼 수 있는 문구입니다.</h4>
</span>

<span sec:authorized="isAnonymous()">
  <h4>로그인 하지 않은 사람만 볼 수 있는 문구입니다.</h4>
</span>
```

<br>

> 위 기능이 제대로 동작하지 않으면 *thymeleaf-extras-springsecurity6* 라이브러리가 제대로 설치된 것인지 확인해 보기

<br><br>

### 서버에서 유저 정보 다루기

```java
(MemberService.java)

@GetMapping("/my-page")
public String myPage(Authentication auth) {

  if (auth != null && auth.isAuthenticated()) {
    User user = (User)auth.getPrincipal();
    System.out.println(user.getUsername());
  }

  return "mypage.html";
}
```

<br>

Authentication auth 파라미터를 통해 로그인중인 유저의 정보를 받아올 수 있다.<br>
만약 로그인하지 않았다면 auth가 null일 수도 있으니<br>`auth != null` 조건도 검사해 주어야 한다.

<br><br>

## auth 변수에 유저정보 더 집어넣기

현재는 auth 변수에 **username**과 **권한**만 들어가 있습니다.<br>이는 `loadUserByUsername()` 메소드에서 반환하는 User 객체에 *username, password, 권한*만 담겨있기 때문입니다.

<br>

`loadUserByUsername`에서 *displayName*도 함께 반환해주면<br>Controller에서도 *displayName*을 사용할 수 있습니다.<br>그러기 위해서는 User를 상속받은 새로운 클래스를 만들어주면 됩니다.

<br>

```java
(MyUserDetailService.java)

public UserDetails loadUserByUsername() {

  (생략)
  CustomUser cu = new CustomUser(member.id, member.username, member.password, member.displayName, authorities);
  return cu;

}

@Getter
@Setter
class CustomUser extends User {
  Long id;
  private String displayName;

  CustomUser(Long id, String username, String password, String displayName, List<GrantedAuthority> authorities) {
    
    super(username, password, authorities);
    this.id = id;
    this.displayName = displayName;

  }
}
```

<br><br>

## 로그아웃

로그아웃은 `SecurityConfig.java`파일에 <br>`http.logout( logout -> logout.logoutUrl("/logout") );`<br>한 줄만 작성해 주면 된다.<br>위 코드는 `/logout`으로 GET요청이 날라오면 로그아웃 시켜준다.

<br><br>

## 세션 유지시간 설정

```
(application.properties)
server.servlet.session.timeout=5s
server.servlet.session.cookie.max-age=5s
```

<br>

`application.properties` 파일에서 세션 유지시간을 설정할 수 있다.<br><br>위 설정대로라면 5초 지나면 로그인이 풀리게 된다.

<br><br>

## DB persist

지금은 사용자의 세션 데이터를 컴퓨터의 메모리 혹은<br>파일 하나를 생성해서 거기에 임시로 저장하고 있다.
<br>
그런 경우 불안정하기 때문에 DB에 세션 데이터를 저장해 두는 것이 안정적이다.
<br>
`spring-session-jdbc` 라이브러리를 설치하면 자동으로 DB에 세션을 저장해 준다.

<br>

```
(build.gradle)

implementation 'org.springframework.session:spring-session-jdbc' 
```

<br>

`build.gradle` 파일에 라이브러리 추가해주고

<br>

```
(application.properties)

spring.session.store-type=jdbc
```

<br>

`application.properties` 파일에 다음과 같이 작성한다.<br>이후 세션 저장용 테이블을 DB에 만들어주면 된다.

<br><br>

## 출처
- [코딩애플 쉽게 배우는 Spring Boot & JPA](https://codingapple.com/course-status/)