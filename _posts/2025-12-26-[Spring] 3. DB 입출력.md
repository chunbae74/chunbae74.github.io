---
title: "[Spring] 3. DB 입출력"
author: chunbae
date: 2025-12-26 00:03:00 +0900
categories: [Spring, Coding_apple]
tags: [spring, jpa, entity, id, column, lombok, thymeleaf]
render_with_liquid: falses
---

## 1. 테이블 만들기

자바 class를 생성하고, 그 위에 `@Entity` 어노테이션을 붙이면 테이블이 생성된다.<br>
클래스의 필드는 테이블의 **열(column)**이 된다.<br><br>
테이블 생성 시에는 id와 같이 행의 고유번호를 지정할 값을 **필수로** 지정해야 한다.<br>해당 값은 필드 위에 `@Id` 어노테이션을 추가하면 된다.<br><br>
다음은 Item이란 이름을 가진 테이블을 만드는 자바 코드이다.<br>Item 테이블은 `id`열, `title`열, `price`열-총 세 개의 열을 가지고 있다.
<br>

```java
(Item.java)

@Entity
public class Item {
    @Id
    public Long  id;

    public String title;
    public Integer price;

}
```

<br><br>

## 2. 각종 어노테이션들

> #### @GeneratedValue(strategy = GenerationType.IDENTITY)

행의 고유번호(Id)의 값을 자동으로 +1만큼 올려준다.

> #### @Column(...)

각 행의 조건들을 설정할 수 있다.<br>예를 들어 String 타입인 title 필드는 최대 255자 밖에 저장하지 못하는데,<br>`@Column(length = 300)` 과 같이 설정하면 최대 저장가능한 문자 길이가 300자로 늘어난다.
<br><br>
`@Column(nullable = false)`를 통해 해당 컬럼에 데이터가 비어 있을 경우엔 저장이 되지 않도록 할 수 있다.
<br><br>
`@Column(unique = true)`를 통해 유니크하지 않은 값이 들어오면 저장이 되지 않도록 할 수 있다.
<br><br>
그 외에도 여러 제약 조건들이 많다.<br>그러나 이 모든 것은 외워야 하는 것이 아닌, 그때그때 인터넷에서 찾아서 하면 된다.
<br>

```java
@Entity
public class Item {
    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    public Long id;
    
    @Column(length = 300)
    public String title;

    @Column(nullable = false)
    public Integer price;
}
```

<br><br>

## 3. Lombok 환경설정

> ### Lombok이란?
Lombok은 자바에서 소스코드를 작성할 때 반복적으로 만들어야 하는 코드를 어노테이션 하나로 자동 생성해주는 라이브러리이다.<br>요령 피운다고 생각하기 쉽지만, 실제로 사용자 수도 많은 유명한 라이브러리임!

<br>

Lombok을 사용하기 위해선 몇 가지 환경설정이 필요하다.<br>먼저, **build.gradle**파일에 아래 라이브러리를 추가한다.
<br>

```
dependencies {
    compileOnly 'org.projectlombok:lombok'
    annotationProcessor 'org.projectlombok:lombok'
}
```

<br><br>

**Lombok 플러그인** 또한 설치해야 한다.<br>

![Desktop View](/assets/img/[Spring]3.DB입출력/img01.png){: width="1471" height="756" }

에디터 상단 메뉴에 **파일 - Setting - annotatoin processor** 검색 후, 체크표시 해 두어야 사용 가능하다.

<br><br>

## 4. DB 데이터 출력

테이블에서 데이터를 입출력하려면 항상 **3-step**이 필요하다.
<br><br>
i.   repository 생성<br>
ii.  DB입출력을 수행하는 클래스에 repository 선언(등록)<br>
iii. DB입출력 문법 사용<br>
<br>

> #### i. repository 생성

먼저, **interface**를 만들어 주어야 한다.<br>인터페이스명은 통상적으로 테이블이름Repository로 짓는다.
<br><br> 인터페이스는 **JpaRepository<T, V>**를 상속(extends)한다.<br>이 때, T에는 테이블 이름이, V에는 테이블의 고유번호 타입이 들어가게 된다.

<br>

```java
public interface ItemRepository extends JpaRepository<Item, Long> {

}
```

인터페이스는 선언**만** 해두면 된다.

<br>

> #### ii. DB입출력을 수행하는 클래스에 repository 선언(등록)

DB입출력을 수행하는 클래스에 step1에서 생성한 인터페이스 타입 변수를 private final으로 선언한다.
<br>Lombok을 이용할 경우, 해당 클래스 위에 `@RequiredArgsConstructor` 어노테이션만 선언해 주면 된다.
<br>

```java
@Controller
@RequiredArgsConstructor
public class ItemController {

    private final ItemRepository itemRepository;

    ...
}
```

<br>*참고: 만약 Lombok을 사용하지 않는다면, 다음과 같이 코드를 작성해야만 한다.*
<br>

```java
@Controller
public class ItemController {
    
    private final ItemRepository itemRepository;

    @Autowired
    ItemController(ItemRepository itemRepository) {
        this.itemRepository = itemRepository;
    }

    ...
}
```

<br><br>

> #### iii. DB입출력 문법 사용

itemRepository에는 DB에 접근하는 메소드들이 잔뜩 들어있다.<br>우리가 할 것은 상황에 맞는 메소드들을 가져다 쓰는 것 뿐이다.
<br><br>
여러 메소드들 중, `findAll`이란 메소드가 있다.<br>해당 메소드는 테이블의 각 열을 원소로 가지는 **List**를 반환한다.
<br>

```java
@Controller
@RequiredArgsConstructor
public class ItemController {

    private final ItemRepository itemRepository;

    @GetMapping("/list")
    public String list() {
        List<Item> items = itemRepository.findAll();
        ...
        return "list.html";
    }

}
```

<br><br>

## 5. DB 데이터를 Thymeleaf로 받아오기

먼저, controller 쪽 소스코드는 다음과 같이 작성하여 HTML로 DB 데이터를 넘겨줄 수 있다.
<br>

```java
@Controller
@RequiredArgsConstructor
public class ItemController {

    private final ItemRepository itemRepository;

    @GetMapping("/list")
    public String list(Model model) {
        List<Item> items = itemRepository.findAll();
        model.addAttribute("items", items);
        return "list.html";
    }

}
```

<br>

HTML 코드 쪽에서는 데이터를 받아 다음과 같이 처리할 수 있다.
<br>

```html
(list.html)

<div>
    <h4 th:text="${items.get(0).title}">상품명</h4>
    <p th:text="${items.get(0).price}">가격</p>
</div>
<div>
   <h4 th:text="${items.get(1).title}">상품명</h4>
    <p th:text="${items.get(1).price}">가격</p>
</div> 
<div>
<h4 th:text="${items.get(2).title}">상품명</h4>
    <p th:text="${items.get(2).price}">가격</p>
</div> 
```

<br><br>
그러나 이는 원소의 개수가 변함에 따라 html 코드를 수정해주어야 하는,<br>비효율적인 코드이다.
<br><br>
자바에서는 for문으로 쉽게 해결 가능한데, 다행히도 Thymeleaf에도 `th:each`를 통해 반복 작업을 수행할 수 있다.
<br><br>`th:each`를 사용해 위 코드를 아래와 같이 바꿀 수 있다.
<br>

```html
(list.html)

<div th:each="item: ${items}">
    <h4 th:text="${item.title}">상품명</h4>
    <p th:text="${item.price}">가격</p>
</div>
```

<br><br>

## 출처
- [코딩애플 쉽게 배우는 Spring Boot & JPA](https://codingapple.com/course-status/)