---
title: "[Spring] 7. Spring Security"
author: chunbae
date: 2026-01-04 00:00:00 +0900
categories: [Spring, Coding_apple]
tags: [spring, security, session, token, jwt, csrf, oauth]
render_with_liquid: falses
---

## 회원기능 동작 방식

<br>

회원기능 동작방식은 다음과 같다.

<br>

**회원가입:**
<br>유저가 가입하면 아이디/비번을 DB에 저장해 둔다

<br>

**로그인:**
<br>1. 유저가 로그인시 아이디/비번을 서버로 보낸다
<br>2. DB와 비교해 본 뒤 이상없으면 **입장권**을 발급해준다

<br>

**로그인이 필요한 서버기능 이용시:**
<br>1. 유저는 서버에 GET/POST로 데이터 요청 시 **입장권**도 함께 제시한다
<br>2. 서버는 입장권 확인 후 데이터나 페이지를 보내준다

<br>

이번 게시글에서는 **입장권**을 어떤 식으로 만드는지 알아볼 것이다.

<br><br>

## 입장권

입장권은 브라우저의 쿠키 저장소에 저장된다.<br>쿠키 저장소에 저장해놓은 쿠키는 서버로 GET/POST요청 시 <br>자동으로 함께 전송되기 때문에 입장권 전송도 편하게 할 수 있다.
<br><br>
입장권을 만드는 방식으로는 크게 Session과 Token 방식이 있다.

<br>

> ### Session 방식

![Desktop View](/assets/img/[Spring]7.SpringSecurity/img01.png){: width="2226" height="765" }_사진 출처 : 코딩애플_

<br>

Session 방식 사용 시, 입장권을 만들 때<br>**session id**만 적어서 발급하면 된다.

<br>

**로그인:**
<br>1. 유저가 로그인하면 DB에 **유저아이디, 유효기간, session id**를 기록해두고
<br>2. 유저에게는 **session id**만 적힌 입장권을 보내준다

<br>

session id는 그냥 행을 구분하기 위한 랜덤 문자나 숫자이다.

<br>

**로그인이 필요한 서버기능 이용 시:**
<br>1. 유저가 GET/POST요청 시 입장권을 서버에 제출한다
<br>2. 서버는 입장권에 써 있는 session id를 가지고 DB를 조회,<br>DB기록에 별 이상이 없으면 GET/POST요청을 진행시켜 준다

<br>

**Session 방식의 장점:**
<br>
매번 GET/POST 요청할 때 마다 DB를 조회해보기 때문에<br>하나하나의 요청마다 엄격하게 유저를 체크해 볼 수 있다.

<br>

**Session 방식의 단점:**
<br>
그 만큼 DB의 부담이 심해질 수 있다.<br>(유저가 많은 사이트들은 Redis 같은 빠른 메모리 DB를 이용하기도 함)

<br><br>

> ### Token 방식

![Desktop View](/assets/img/[Spring]7.SpringSecurity/img02.png){: width="1221" height="494" }_사진 출처 : 코딩애플_

<br>

대부분 JWT와 혼용하기 때문에 필자는 JWT(JSON Web Token)이라 하겠다.<br>JWT 방식을 사용한다면 입장권에 많은 정보를 기록해놓기에 DB조회를 안해도 된다.

<br>

**로그인:**
<br>1. 유저가 로그인하면 *유저의 아이디, 로그인 날짜, 유효기간*<br>등이 암호화되어 적혀있는 입장권을 발급해 준다

<br>

**로그인이 필요한 서버기능 이용 시:**
<br>1. 유저가 GET/POST요청 시, 입장권의 유효기간을 확인해 본 다음<br>별 이상 없으면 통과시켜 준다
<br>유저정보가 필요하면 입장권에 써있는걸 꺼내서 사용한다

<br>

입장권을 위조하면 어떻게 되는 것인가 하고 걱정이 들 수도 있다.<br>그러나 JWT 자체를 위조하는 것은 불가능에 가까우므로 걱정하지 않아도 된다.

<br>

**JWT 방식의 장점:**
<br>
매번 GET/POST 요청할 때 마다 DB를 조회할 필요가 없어서 DB 부담이 적다.<br>유저가 매우 많거나 마이크로서비스형태로 서버를 여러개 운영하는 사이트들이 즐겨쓰는 이유이다.

<br>

**JWT 방식의 단점:**
<br>
한 번 발급된 JWT는 서버가 제어할 수 없다.<br>만약 누군가가 이미 발급된 JWT를 탈취한다고 하더라도 그 사람의 로그인을 막거나 할 수 있는 방법이 없다.<br><br>물론 블랙리스트를 DB에 기록해 두면 되지만,<br>그러면 매번 JWT 사용마다 DB를 조회해야 하므로 Session 방식과 다를 바 없어진다.

<br><br>

## Spring Security 라이브러리

Spring에서는 실제로는 이 모든것을 직접 구현하는 대신,<br>spring security 라이브러리를 사용한다.

<br>

### spring security 라이브러리 설치

```
implementation 'org.springframework.boot:spring-boot-starter-security'
implementation 'org.thymeleaf.extras:thymeleaf-extras-springsecurity6:3.1.1.RELEASE' 
```

<br>

`bundle.gradle` 파일에 두 줄을 추가해준다.<br>아무 설정도 하지 않은 상태로 서버를 재시작했을 때<br>로그인 창이 뜨면은 라이브러리가 성공적으로 설치된 것이다.

<br>

### 기본 설정

모든 페이지를 막아두는 것이 기본으로 설정되어 있다.
<br><br>spring security는 `@EnableWebSecurity` 어노테이션이 붙은 클래스를 하나 만들고선<br>그 안에서 이것저것 설정을 바꿀 수 있다.
<br><br>참고로 클래스명은 아무렇게나 지어도 상관없다.

<br>

```java
(SecurityConfig.java) 

@Configuration
@EnableWebSecurity
public class SecurityConfig { 

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http.authorizeHttpRequests((authorize) -> 
            authorize.requestMatchers("/**").permitAll()
        );

        return http.build()
    }

}
```

<br>

`.requestMatchers()`를 이용하여 URL을 지정할 수 있다.<br>`/**`는 모든 URL이란 뜻이다.

<br>

위 코드처럼 작성 시 모든 URL 접속 시 모든 유저의 접속을 허락해준다.

<br><br>

### CSRF 보안기능

```java
(SecurityConfig.java)

@Configuration
@EnableWebSecurity
public class SecurityConfig {

  @Bean
  public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
    
    http.csrf((csrf) -> csrf.disable());

    http.authorizeHttpRequests((authorize) ->
        authorize.requestMatchers("/**").permitAll()
    );
    
    return http.build();
  }

}
```

<br>

위에처럼 작성하면 CSRF 보안기능이 꺼진다.<br><br>`<form>`을 비슷하게 위조하면은 다른 사이트에서 내 사이트로<br>POST 요청을 날려 테러행위 같은 것을 할 수 있는데, 이를 **CSRF 공격**이라고 한다.
<br><br>
CSRF 방어법으로는 브라우저가 자동으로 보내주는 정보(쿠키)외에<br>**서버만 알 수 있는 추가정보-가령 임의의 난수 토큰**를 요구하는 것이다.
<br><br>
사용자가 form 전송 시 토큰도 함께 전송해야 하며,<br>서버에서는 이 토큰이 유효할 때만 반응하도록 설계하면 된다.
<br><br>
JWT는 입장권을 쿠키에 넣어서 직접 보내는 것이 아니라<br>AJAX 요청 시 headers 부가정보 기입란에 적어서 보내기 때문에<br>CSRF를 간단하게 예방할 수 있다.
<br><br>
따라서 JWT를 사용할 때는 CSRF 기능을 끄는 경우가 많다.

<br><br>

반대로, 보안 기능을 키고 싶다면 다음과 같이 작성하면 된다.

<br>

```java
(SecurityConfig.java)

@Configuration
@EnableWebSecurity
public class SecurityConfig {

  @Bean
  public CsrfTokenRepository csrfTokenRepository() {
    HttpSessionCsrfTokenRepository repository = new HttpSessionCsrfTokenRepository();
    repository.setHeaderName("X-XSRF-TOKEN");
    return repository;
  }

  @Bean
  public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
    
    http.csrf((csrf) -> csrf.csrfTokenRepository(csrfTokenRepository())
      .ignoringRequestMatchers("/login")
    );

    http.authorizeHttpRequests((authorize) ->
        authorize.requestMatchers("/**").permitAll()
    );
    
    return http.build();
  }

}
```

<br><br>

html 에서 다음과 같이 form 태그를 작성하면<br>서버에서 CSRF토큰을 발급해 주고, form 전송 시<br>자동으로 서버로 전달된다.

<br>

```html
<input type="hidden" th:name="${_csrf.parameterName}" th:value="${_csrf.token}"> 
```

<br>

만약 내 form이 아닌, 다른 form이 서버로 들어온다면<br>CSRF 토큰이 없기 때문에 403 에러를 내면서 차단된다.

<br>

CSRF 기능을 켜게 되면 모든 폼과 AJAX 요청에 CSRF 토큰을<br>서버에서 받아온 다음에 그걸 함께 전송해야 한다.

<br><br>

## OAuth (Open Authorization)

OAuth는 비밀번호를 직접 공유하지 않고도 B 사이트가가 A 사이트 데이터에<br>접근할 수 있도록 권한을 부여하는 **개방형 표준 인증 프로토콜**이다.
<br><br>
OAuth의 예시로는<br>
* 구글계정(사이트 A)을 이용하여 B 사이트에 회원가입<br>
* 페이스북에 별도 로그인 없이도<br>내 페이스북 사진을 사이트 B에 불러오기
<br>

등이 있다.

<br>

### OAuth의 동작 원리

아래는 가장 많이 쓰이는 Authorization Code Grant 방식을 기준으로 설명한 것이다.

<br>1. **권한 요청**: 사용자가 앱에서 `구글로 로그인` 버튼을 누른다.
<br>2. **사용자 승인**: 구글 로그인 창이 뜨고, 사용자가 구글 아이디/비번을 입력한 뒤 정보 제공 동의 버튼을 누른다.
<br>3. **Authorization Code 발급**: 구글이 앱에게 일회용 인증 코드를 전달한다.
<br>4. **Access Token 교환**: 앱은 이 코드를 가지고 구글 인증 서버로 가서 진짜 권한인 Access Token과 바꾼다.
<br>5. **데이터 접근**: Access Token을 이용해 구글에서 원하는 데이터에 접근한다.

<br>

**OAuth의 장점:**
<br>- **보안성**: 사용자는 제3의 앱에서 자신의 비밀번호를 알려줄 필요가 없다.
<br>- **제한적 권한**: *사진 조회만 허용*, *이메일 주소만 확인* 등 필요한 권한만 골라서 부여할 수 있다.
<br>- **간편성**: 사용자는 여러 사이트의 비번을 기억할 필요 없이 기존 계정(구글, 카카오 등)으로 편리하게 가입할 수 있다.
<br>- **권한 취소**: 사용자가 구글 설정에서 '이 앱의 권한 취소'를 누르면, 비번을 바꾸지 않고도 특정 앱의 접근만 막을 수 있다.

<br>

**OAuth와 JWT의 관계**

<br>

OAuth와 JWT는 역할이 다르다.<br>

**OAuth**는 어떻게 권한을 획득할 것인가에 대한 **절차(Framework)** 이다.
<br>반면에 **JWT**는 그 권한 정보를 담고 있는 **데이터 형식(Token)** 이다.
<br>
즉, **OAuth 발급 과정에서 발급해주는 'Access Token'을 JWT 형식으로 만드는 경우**가 매우 많다.

<br><br>

## 출처
- [코딩애플 쉽게 배우는 Spring Boot & JPA](https://codingapple.com/course-status/)